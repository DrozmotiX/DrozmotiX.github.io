(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{450:function(n,e,t){"use strict";t.r(e);var a=t(21),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"yaml-vorlagen"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yaml-vorlagen"}},[n._v("#")]),n._v(" YAML Vorlagen")]),n._v(" "),t("p",[n._v("Um euch den einstieg in ESPHome zu erleichtern findet ihr hier, mit grossen dank an fleissiegen Helfern, einige Beispiele fuer weit verbreitete geraete.")]),n._v(" "),t("div",{staticClass:"custom-block danger"},[t("p",{staticClass:"custom-block-title"},[n._v("Achtung")]),n._v(" "),t("p",[n._v("Es "),t("em",[n._v("extrem")]),n._v(" wichtig die Einstellungen zu √ºberpr√ºfen, wenn man etwas in der eigentlichen YAML-Konfiguration vergisst, kann es leider passieren das man sich erst einmal vom Ger√§t ausschlie√üt.")])]),n._v(" "),t("h2",{attrs:{id:"secrets-yaml"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#secrets-yaml"}},[n._v("#")]),n._v(" SECRETS.YAML")]),n._v(" "),t("p",[n._v('Die "SECRETS.YAML" erm√∂glicht es dir, oft genutzte Konfigurationen schnell und effizient zu hinterlegen.\nDie meisten Einstellungen wiederholen sich f√ºr die meisten Module, z.B. WLAN SSID, WLAN Passw√∂rter, API Zugang etc.\nDarum sollten die wichtigsten Einstellungen direkt dort hinterlegt werden, so l√§uft man nicht direkt Gefahr etwas vergessen zu haben.')]),n._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[n._v("Kann ich die Einstellungen nicht auch in der YAML-Konfiguration direkt vornehmen?")]),n._v(" "),t("p",[n._v("Selbstverst√§ndlich! - ABER: Du musst dann in jeder Konfiguration die richtigen Einstellungen immer und immer wieder eintragen."),t("br"),n._v("\nIst es nicht sch√∂ner einfach ein paar grunds√§tzliche Sachen schnell per Copy+Paste in der Konfiguration einzuf√ºgen?")])]),n._v(" "),t("details",[t("summary",[n._v(" SECRETS.YAML Vorlage anzeigen\n")]),n._v(" "),t("div",{staticClass:"custom-block danger"},[t("p",{staticClass:"custom-block-title"},[n._v("WARNING")]),n._v(" "),t("p",[n._v("Folgende Punkte "),t("em",[n._v("SOLLTEN")]),n._v(" auf jeden Fall in eurer SECRETS.YAML vor dem flashen zu finden sein:")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('# Over The Air\nota_password: "esphomeota"          # Passwort um per "Over-the-Air" ein Update durchf√ºhren zu k√∂nnen\n\n# API Access\napi_password: "esphomeapi"              # Passwort zum aktivieren der ESPHome API, zur Steuerung z.b. √ºber IOBroker, Logging etc.\n\n# WiFi\nwifi_ssid:        "SSID eures WLANs"                    # Damit verbinden sich eure ESP Home Devices beim Reboot\nwifi_password:    "PASSWORT eures WLANs"    # das Passwort geh√∂rt zur gew√ºnschten SSID\nip_gateway:       192.168.0.254                        # Falls ihr manuelle IPs vergeben wollt, k√∂nnen hier die grundlegenden\nip_netmask:       255.255.255.0                           # Konfigurationen vorgenommen werden. Diese stehen dann in den Configs\nip_dns_1:         8.8.8.8                                       # als Platzhalter zur Verf√ºgung.\nip_dns_2:         192.168.0.254                            \nip_domain:        .local\n')])])]),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[n._v("OPTIONAL")]),n._v(" "),t("p",[n._v("In einigen der Vorlagen findet Ihr Informationen f√ºr die manuelle IP Vergabe.\nAn dieser Stelle wird eine kurze √úbersicht gezeigt, wie man sich schnell und √ºbersichtlich seine Ger√§te einpflegen kann.\nEs m√ºssen bei der Verwendung dann nur minimale √Ñnderungen in der eigentlichen YAML-Konfiguration vorgenommen werden.")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("# Device-List Gosund SP1\nIP-Konfiguration            IP                     # Device-Name           Kommentar\nip_gosund_sp1_1:      192.168.0.41   # Gosund_SP1_1      - Laserdrucker\nip_gosund_sp1_2:      192.168.0.42   # Gosund_SP1_2      - 3D Drucker\nip_gosund_sp1_3:      192.168.0.43   # Gosund_SP1_3      - Reserve #3\nip_gosund_sp1_4:      192.168.0.44   # Gosund_SP1_4      - Reserve #4\n\n# Device-List Gosund SP112\nip_gosund_sp112_1:    192.168.0.40   # Gosund_SP112_1    - PC/USV\nip_gosund_sp112_2:    192.168.0.45   # Gosund_SP112_2    - Reserve\n\n# Device-List Blitzwolf SHP7\nip_blitzwolf_shp7_1:  192.168.0.31   # Blitzwolf_SHP7_1  - Reserve\nip_blitzwolf_shp7_2:  192.168.0.32   # Blitzwolf_SHP7_2  - Reserve\n")])])]),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[n._v("OPTIONAL")]),n._v(" "),t("p",[n._v("An erster Stelle ist der Platzhalter f√ºr die Konfiguration, dann folgt die manuelle IP-Zuweisung f√ºr das Ger√§t.\nZur Vereinfachung nutzen wir das # - Zeichen als Kommentar und tragen dort ggf. noch den Friendly-Name des Moduls sowie eine sinnvolle Bezeichnung ein.")])])]),n._v(" "),t("h2",{attrs:{id:"faq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[n._v("#")]),n._v(" FAQ")]),n._v(" "),t("h3",{attrs:{id:"api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api"}},[n._v("#")]),n._v(" api:")]),n._v(" "),t("p",[n._v("Eine der wichtigsten Einstellungen √ºberhaupt. Diese erm√∂glicht den Zugriff auf das Modul zur Steuerung, ohne diese interne Modul-API macht das ESPHome keinen Sinn.")]),n._v(" "),t("h3",{attrs:{id:"ota"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ota"}},[n._v("#")]),n._v(" ota:")]),n._v(" "),t("p",[n._v('Ebenfalls eine sehr wichtige Einstellung. Diese erm√∂glicht den Zugriff auf das Modul zum updaten "Over-The-Air (OTA)". Das Modul erlaubt das √§ndern der Konfiguration (Updates, neue Features etc.) √ºber einen direkten Upload zum Modul.')]),n._v(" "),t("h3",{attrs:{id:"substitutions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#substitutions"}},[n._v("#")]),n._v(" substitutions")]),n._v(" "),t("p",[n._v('device_id - Das ist die sogenannte "Unique-ID", ein einmaliges Erkennungszeichen f√ºr das Modul. Nur Kleinschreibung, keine Sonderzeichen (au√üer _ Unterstrich) !\ndevice_name - Der Name der in diversen Kategorien erscheint (z.b. IoBroker). Nur Kleinschreibung, keine Sonderzeichen (au√üer _ Unterstrich)!\nfriendly_name - Der Name f√ºr das Modul zur schnellen Identifizierung - Hier ist Gro√ü- und Kleinschreibung, sowie _ Unterstrich und - Minus erlaubt üòÉ')]),n._v(" "),t("p",[n._v("Unter Substitutions finden sich manchmal auch current_res und voltage_div?")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("current_res:"),t("br"),n._v("\nDie Faktor-Berechnung f√ºr den Stromverbrauch im Watt Bereich. Die Kalibrierung ist individuell f√ºr jedes Modul anzupassen. Die Werte weichen bei jedem Modul mitunter massiv ab, es gibt keine groben Richtwerte.\nWenn eure Watt-Werte zu hoch sind, dann ist der Wert nach oben (!) zu korrigieren (Beispiel: 10 Watt werden genutzt, die Messung zeigt 15 Watt an, dann den Wert nach oben korrigieren)\nWenn eure Watt-Werte zu niedrig sind, dann ist der Wert nach unten (!) zu korrigieren. (Beispiel: 10 Watt werden genutzt, die Messung zeigt 8 Watt an, dann den Wert nach unten korrigieren)")])]),n._v(" "),t("li",[t("p",[n._v("voltage_div:\nDie Faktor-Berechnung f√ºr die Spannungmessung.\nWenn eure Volt-Werte zu hoch sind, dann ist der Wert nach oben zu korrigieren (Beispiel: 226V an der Steckdose, die Messung zeigt 240V, dann den Wert nach unten korrigieren)\nWenn eure Volt-Werte zu niedrig sind, dann ist der Wert nach unten zu korrigieren (Beispiel: 226V an der Steckdose, die Messung zeigt 220V, dann den Wert nach oben korrigieren)")])])]),n._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[n._v("Kalibrierung")]),n._v(" "),t("p",[n._v('Eine 100%-tige Kalibrierung ist sehr aufwendig und mit herk√∂mmlichen Messger√§ten kaum zu ermitteln. Dennoch lassen sich die Module auf einen relativ genauen Wert justieren.\nDazu einfach mit einem Wert anfangen (z.b. "current_res") und euer Modul per Upload neu flashen. Zur Ermittlung sollte man ein adequates Messger√§t benutzen und ein Ger√§t was eine relativ konstante Leistung abgibt (z.b 60 Watt Gl√ºhbirne oder √§hnliches).\nDanach auf die gleiche Weise mit (z.b. "voltage_div") vorgehen.\nImmer daran denken - es kann und wird im Leistungsbereich immer mal Abweichungen geben. Die Messungen erfolgen nicht in Echtzeit in den Modulen und es gibt immer Toleranzen in den Chips.')])]),n._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[n._v("ADVANCED USERS")]),n._v(" "),t("p",[n._v("Ein englisches Tutorial findet ihr unter:\nCalibrate Power Source: https://frenck.dev/calibrating-an-esphome-flashed-power-plug/")])]),n._v(" "),t("h2",{attrs:{id:"blitzwolf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blitzwolf"}},[n._v("#")]),n._v(" BLITZWOLF")]),n._v(" "),t("h3",{attrs:{id:"shp7"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shp7"}},[n._v("#")]),n._v(" SHP7")]),n._v(" "),t("details",[t("summary",[n._v(" Vorlage anzeigen\n")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('####\n#\n# Configuration File for BLITZWOLF SHP7 (Dual Plug)\n# - If you switch from Tasmota - check if you have HLW8012 in your template then this config can be used.\n#\n# Notices:\n# ========\n# - There are different versions of SP112 / SHP5, they differ with other GPIO-Pinouts and other sensor platforms!\n# - You have to create a "SECRETS.YAML" first (!) and VALIDATE (!) this configuration before uploading to plug!!!\n#\n# Useful Links:\n# ========\n# Calibrate Power Source: https://frenck.dev/calibrating-an-esphome-flashed-power-plug/\n# To finetune your wattage/voltage measurement, check the substitutions "current_res / voltage_div"\n#\n# Builddate: 14.04.2021 by X-R4Y\n#\n####\nsubstitutions:\ndevice_id:      blitzwolf_shp7  # Device-ID Unique (only lowercase!)\ndevice_name:    blitzwolf_shp7  # Device-Type for Category (only lowercase!)\nfriendly_name:  blitzwolf_shp7  # Device-Name for Channel (Lower-/Uppercase allowed)\ncurrent_res:    \'0.001906\'        # Higher value gives lower watt readout (Default 0.001906)\nvoltage_div:    \'912\'             # Lower value gives lower voltage readout (Default 912 ~ 226V)\n\nesphome:\nname: $device_name\nplatform: ESP8266\narduino_version: 2.5.1\nboard: esp8285\n\nwifi:\nssid:         !secret wifi_ssid\npassword:     !secret wifi_password\nfast_connect: on                  # Useful if WIFI-SSID is hidden\n\n# Optional manual IP\n#  manual_ip:\n#    static_ip:  !secret ip_blitzwolf_shp7\n#    gateway:    !secret ip_gateway\n#    subnet:     !secret ip_netmask\n#    dns1:       !secret ip_dns_1\ndomain:       !secret ip_domain\n\n# Enable fallback hotspot (captive portal) in case wifi connection fails\n#  ap:\n#    ssid: $device_name_Hotspot_Fallback\n#    password: "fallback"\n\n# Enable if you wish to have a minimalistic web-interface for your device\n#web_server:\n#  port: 80\n\nlogger:\nbaud_rate: 0\n\napi:\npassword: !secret api_password\n\nota:\npassword: !secret ota_password\n\nsensor:\n- platform: hlw8012\n  sel_pin:\n  number: GPIO03\n  inverted: true\n  cf_pin: GPIO04\n  cf1_pin: GPIO05\n  current_resistor: ${current_res}\n  voltage_divider: ${voltage_div}\n\n  current:\n  id: current\n  name: ${friendly_name}_Current\n  unit_of_measurement: \'A\'\n  accuracy_decimals: 3\n\n  voltage:\n  id: voltage\n  name: ${friendly_name}_Voltage\n  unit_of_measurement: \'V\'\n  accuracy_decimals: 1\n\n  power:\n  id: wattage\n  name: ${friendly_name}_Power\n  unit_of_measurement: W\n  accuracy_decimals: 2\n  filters:\n  - lambda: return (x / 2.2);\n  change_mode_every: 4\n  update_interval: 10s\n\n  energy:\n  name: ${friendly_name}_Energy\n  unit_of_measurement: "Wh"\n\n- platform: total_daily_energy\n  power_id: wattage\n  name: ${friendly_name}_Daily_Energy\n  unit_of_measurement: kWh\n  filters:\n  # Multiplication factor from W to kW is 0.001\n  - multiply: 0.001\n\n- platform: wifi_signal\n  name: ${friendly_name}_WiFi_Information\n  update_interval: 60s\n\n- platform: uptime\n  id: uptime_sensor\n  name: ${friendly_name}_Uptime_Information\n  update_interval: 60s\n  on_raw_value:\n  then:\n  - text_sensor.template.publish:\n  id: uptime_readable\n  state: !lambda |-\n  int seconds = round(id(uptime_sensor).raw_state);\n  int days = seconds / (24 * 3600);\n  seconds = seconds % (24 * 3600);\n  int hours = seconds / 3600;\n  seconds = seconds % 3600;\n  int minutes = seconds /  60;\n  seconds = seconds % 60;\n  return (\n  (days ? String(days) + "d " : "") +\n  (hours ? String(hours) + "h " : "") +\n  (minutes ? String(minutes) + "m " : "") +\n  (String(seconds) + "s")\n  ).c_str();\n\nbinary_sensor:\n- platform: gpio\n  id: hw_button1\n  name: hw_button1\n  internal: true\n  pin:\n  number: GPIO0\n  mode: INPUT_PULLUP\n  inverted: true\n  on_press:\n  - switch.toggle: relay1\n\n- platform: gpio\n  id: hw_button2\n  name: hw_button2\n  internal: true\n  pin:\n  number: GPIO12\n  mode: INPUT_PULLUP\n  inverted: true\n  on_press:\n  - switch.toggle: relay2\n\noutput:\n- platform: esp8266_pwm\n  id: red_led1\n  pin:\n  number: GPIO13\n  inverted: true\n- platform: esp8266_pwm\n  id: red_led2\n  pin:\n  number: GPIO2\n  inverted: true\n\nswitch:\n- platform: gpio\n  pin: GPIO14\n  id: relay1\n  name: ${friendly_name}_Relay_1\n  on_turn_on:\n  - output.turn_on: red_led1\n    on_turn_off:\n  - output.turn_off: red_led1\n- platform: gpio\n  pin: GPIO16\n  id: relay2\n  name: ${friendly_name}_Relay_2\n  on_turn_on:\n  - output.turn_on: red_led2\n    on_turn_off:\n  - output.turn_off: red_led2\n\n- platform: template\n  id: relay_combined\n  name: ${friendly_name}_Combined_Relay\n  optimistic: true\n  turn_off_action:\n  - output.turn_off: red_led1\n  - output.turn_off: red_led2\n  - switch.turn_off: relay1\n  - switch.turn_off: relay2\n    turn_on_action:\n  - output.turn_on: red_led1\n  - output.turn_on: red_led2\n  - switch.turn_on: relay1\n  - switch.turn_on: relay2\n\n# ==============\n# !!! Notice !!!\n# ==============\n# If enabled, the Blue LED will flash while transmitting data (Power Measuring, Statusmessages and such stuff)\n# If disabled, you wont get any error flashings on the LED from the plug. (Default)\n# To enable the status LED feature put # in front of the following 4 lines\n#status_led:\n#  pin:\n#    number: GPIO01\n#    inverted: true\n\n# Enable time component to reset energy at midnight\ntime:\n- platform: sntp                        # Uses NTP protocol for time information\n  id: my_time                           # Uses my local time from compiling\n\ntext_sensor:\n- platform: template\n  name: ${friendly_name}_Uptime         # Enable Uptime-Sensor in readable format    \n  id: uptime_readable\n  icon: mdi:clock-start\n- platform: version\n  name: ${friendly_name}_version        # Show module Version in structure\n- platform: wifi_info\n  ip_address:\n  name: ${friendly_name}_ip           # Show WIFI IP-address in structure\n  ssid:\n  name: ${friendly_name}_ssid         # Show WIFI SSID in structure\n  bssid:\n  name: ${friendly_name}_bssid        # Show WIFI BSSID in structure\n')])])])]),n._v(" "),t("h2",{attrs:{id:"gosund"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gosund"}},[n._v("#")]),n._v(" Gosund")]),n._v(" "),t("h3",{attrs:{id:"sp1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sp1"}},[n._v("#")]),n._v(" SP1")]),n._v(" "),t("details",[t("summary",[n._v(" Vorlage anzeigen\n")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('####\n#\n# Configuration File for GOSUND SP1\n# - If you switch from Tasmota - check if you have HLW8012 in your template then this config can be used.\n#\n# Notices:\n# ========\n# - There are different versions of SP1, they differ with other GPIO-Pinouts and other sensor platforms!\n# - You have to create a "SECRETS.YAML" first (!) and VALIDATE (!) this configuration before uploading to plug!!!\n#\n# Useful Links:\n# ========\n# Calibrate Power Source: https://frenck.dev/calibrating-an-esphome-flashed-power-plug/\n# To finetune your wattage/voltage measurement, check the substitutions "current_res / voltage_div"\n#\n# Builddate: 14.04.2021 by X-R4Y\n#\n####\nsubstitutions:\ndevice_id:      gosund_sp1      # Device-ID Unique\ndevice_name:    gosund_sp1  # Device-Type for Category\nfriendly_name:  gosund_sp1 # Device-Name for Channel\ncurrent_res:    \'0.001906\'        # Higher value gives lower watt readout (Default 0.001906)\nvoltage_div:    \'960\'             # Lower value gives lower voltage readout\n\nesphome:\nname: $device_name\nplatform: ESP8266\nboard: esp8285\n\nwifi:\nssid:         !secret wifi_ssid\npassword:     !secret wifi_password\nfast_connect: on\n\n# Optional manual IP\n#  manual_ip:\n#    static_ip:  !secret ip_gosund_sp1\n#    gateway:    !secret ip_gateway\n#    subnet:     !secret ip_netmask\n#    dns1:       !secret ip_dns_1\ndomain:       !secret ip_domain\n\n# Enable fallback hotspot (captive portal) in case wifi connection fails\n#  ap:\n#    ssid: $device_name_Hotspot_Fallback\n#    password: "fallback"\n\n# Enable if you wish to have a minimalistic web-interface for your device\n#web_server:\n#  port: 80\n\nlogger:\n# https://esphome.io/components/logger\n\napi:\npassword: !secret api_password\n\nota:\npassword: !secret ota_password\n\nsensor:\n- platform: hlw8012\n  # https://esphome.io/components/sensor/hlw8012.html\n  # current, power, voltage can all use sensor options https://esphome.io/components/sensor/#config-sensor\n  sel_pin:\n  number: GPIO12\n  inverted: True\n  cf_pin: GPIO5\n  cf1_pin: GPIO14\n\n  current:\n  name: ${friendly_name}_Current\n  unit_of_measurement: A\n  accuracy_decimals: 3\n\n  power:\n  name: ${friendly_name}_Power\n  id: power_monitor_value\n  unit_of_measurement: W\n  accuracy_decimals: 2\n  filters:\n  - lambda: return (x / 2.2);\n\n  voltage:\n  name: ${friendly_name}_Voltage\n  unit_of_measurement: V\n  accuracy_decimals: 2\n  current_resistor: $current_res\n  voltage_divider: $voltage_div\n  change_mode_every: 5            # default 8\n  update_interval: 15s            # default 60s\n\n  energy:\n  name: ${friendly_name}_Energy\n  unit_of_measurement: "Wh"\n\n- platform: total_daily_energy\n  name: ${friendly_name}_Total_Daily_Energy\n  power_id: power_monitor_value\n  filters:\n  - multiply: 0.001         # convert Wh to kWh\n    unit_of_measurement: kWh\n\n- platform: wifi_signal\n  name: ${friendly_name}_WiFi_Information\n  update_interval: 60s\n\n- platform: uptime\n  name: ${friendly_name}_Uptime_Information\n  id: uptime_sensor\n  update_interval: 60s\n  on_raw_value:\n  then:\n  - text_sensor.template.publish:\n  id: uptime_readable\n  state: !lambda |-\n  int seconds = round(id(uptime_sensor).raw_state);\n  int days = seconds / (24 * 3600);\n  seconds = seconds % (24 * 3600);\n  int hours = seconds / 3600;\n  seconds = seconds % 3600;\n  int minutes = seconds /  60;\n  seconds = seconds % 60;\n  return (\n  (days ? String(days) + "d " : "") +\n  (hours ? String(hours) + "h " : "") +\n  (minutes ? String(minutes) + "m " : "") +\n  (String(seconds) + "s")\n  ).c_str();\n\nbinary_sensor:\n# Hardware Button at plug to turn on/off relay manually\n- platform: gpio\n  pin:\n  number: GPIO13\n  id: button\n  name: ${friendly_name}_Button\n  on_press:\n  - switch.toggle: relay_template\n    internal: True\n\noutput:\n# Hardware LEDs: Blue and Red, triggering on different states\n- platform: gpio\n  id: red_led_output    # Status LED RED\n  pin:\n  number: GPIO0\n  inverted: True\n\n- platform: gpio\n  id: blue_led_output   # Status LED BLUE\n  pin:\n  number: GPIO2\n  inverted: True\n\nswitch:\n# Hardware Relay: Relay that triggers the output plug\n- platform: gpio\n  pin: GPIO15\n  id: relay\n\n- platform: template\n  name: ${friendly_name}_Relay\n  id: relay_template\n  lambda: |-\n  if (id(relay).state) {\n  return true;\n  } else {\n  return false;\n  }\n  turn_on_action:\n  - output.turn_on: blue_led_output   # Turns on blue LED while relay on\n  - output.turn_off: red_led_output   # Turns off red LED while relay on\n  - switch.turn_on: relay             # Turns relay on\n    turn_off_action:\n  - output.turn_off: blue_led_output  # Turns off blue LED while relay off\n  - output.turn_on: red_led_output    # Turns on red LED while relay off\n  - switch.turn_off: relay            # Turns relay off\n\n# ==============\n# !!! Notice !!!\n# ==============\n# If enabled, the Red LED will not light up while relay is in off-state!\n# To disable the status LED feature put # in front of the following 4 lines\n# If disabled, you wont get any error flashings on the LED from the plug.\n#status_led:\n#  pin:\n#    number: GPIO0                         # Default: RED GPIO0 / BLUE GPIO2\n#    inverted: true\n\n# Enable time component to reset energy at midnight\ntime:\n- platform: sntp                        # Uses NTP protocol for time information\n  id: my_time                           # Uses my local time from compiling\n\ntext_sensor:\n- platform: template\n  name: ${friendly_name}_Uptime         # Enable Uptime-Sensor in readable format    \n  id: uptime_readable\n  icon: mdi:clock-start\n- platform: version\n  name: ${friendly_name}_version        # Show module Version in structure\n- platform: wifi_info\n  ip_address:\n  name: ${friendly_name}_ip           # Show WIFI IP-address in structure\n  ssid:\n  name: ${friendly_name}_ssid         # Show WIFI SSID in structure\n  bssid:\n  name: ${friendly_name}_bssid        # Show WIFI BSSID in structure\n')])])])]),n._v(" "),t("h3",{attrs:{id:"sp111"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sp111"}},[n._v("#")]),n._v(" SP111")]),n._v(" "),t("details",[t("summary",[n._v(" Vorlage anzeigen\n")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('####\n#\n# Configuration File for GOSUND SP111\n#\n# Notices:\n# ========\n# - You have to create a "SECRETS.YAML" first (!) and VALIDATE (!) this configuration before uploading to plug!!!\n#\n# Useful Links:\n# ========\n# Calibrate Power Source: https://frenck.dev/calibrating-an-esphome-flashed-power-plug/\n# To finetune your wattage/voltage measurement, check the substitutions "current_res / voltage_div"\n#\n# Builddate: 14.04.2021 by X-R4Y\n#\n####\nsubstitutions:\ndevice_id:      gosund_sp111      # Device-ID Unique\ndevice_name:    gosund_sp111      # Device-Type for Category\nfriendly_name:  gosund_sp111      # Device-Name for Channel\ncurrent_res:    \'0.0012\'          # Higher value gives lower watt readout (Default 0.0012)\nvoltage_div:    \'777\'             # Lower value gives lower voltage readout\n\nesphome:\nname: $device_name\nplatform: ESP8266\nboard: esp8285\n\nwifi:\nssid:         !secret wifi_ssid\npassword:     !secret wifi_password\nfast_connect: on\n\n# Optional manual IP\n#  manual_ip:\n#    static_ip:  !secret ip_gosund_sp1_1\n#    gateway:    !secret ip_gateway\n#    subnet:     !secret ip_netmask\n#    dns1:       !secret ip_dns_1\ndomain:       !secret ip_domain\n\n# Enable fallback hotspot (captive portal) in case wifi connection fails\n#  ap:\n#    ssid: $device_name_Hotspot_Fallback\n#    password: "fallback"\n\n# Enable if you wish to have a minimalistic web-interface for your device\n#web_server:\n#  port: 80\n\nlogger:\n# https://esphome.io/components/logger\n\napi:\npassword: !secret api_password\n\nota:\npassword: !secret ota_password\n\nsensor:\n- platform: hlw8012\n  # https://esphome.io/components/sensor/hlw8012.html\n  # current, power, voltage can all use sensor options https://esphome.io/components/sensor/#config-sensor\n  sel_pin:\n  number: GPIO12\n  inverted: True\n  cf_pin: GPIO5\n  cf1_pin: GPIO14\n\n  current:\n  name: ${friendly_name}_Current\n  unit_of_measurement: A\n  accuracy_decimals: 3\n\n  power:\n  name: ${friendly_name}_Power\n  id: power_monitor_value\n  unit_of_measurement: W\n  accuracy_decimals: 2\n#      filters:\n#      - multiply: 0.5\n      filters:\n        - lambda: return (x / 2.2);\n\n    voltage:\n      name: ${friendly_name}_Voltage\n      unit_of_measurement: V\n      accuracy_decimals: 2\n    current_resistor: $current_res\n    voltage_divider: $voltage_div\n    change_mode_every: 3            # default 10\n    update_interval: 10s            # default 60s\n\n    energy:\n      name: ${friendly_name}_Energy\n      unit_of_measurement: "Wh"\n\n- platform: total_daily_energy\n  name: ${friendly_name}_Total_Daily_Energy\n  power_id: power_monitor_value\n  filters:\n  - multiply: 0.001         # convert Wh to kWh\n    unit_of_measurement: kWh\n\n- platform: wifi_signal\n  name: ${friendly_name}_WiFi_Information\n  update_interval: 60s\n\n- platform: uptime\n  name: ${friendly_name}_Uptime_Information\n  id: uptime_sensor\n  update_interval: 60s\n  on_raw_value:\n  then:\n  - text_sensor.template.publish:\n  id: uptime_readable\n  state: !lambda |-\n  int seconds = round(id(uptime_sensor).raw_state);\n  int days = seconds / (24 * 3600);\n  seconds = seconds % (24 * 3600);\n  int hours = seconds / 3600;\n  seconds = seconds % 3600;\n  int minutes = seconds /  60;\n  seconds = seconds % 60;\n  return (\n  (days ? String(days) + "d " : "") +\n  (hours ? String(hours) + "h " : "") +\n  (minutes ? String(minutes) + "m " : "") +\n  (String(seconds) + "s")\n  ).c_str();\n\nbinary_sensor:\n# Hardware Button at plug to turn on/off relay manually\n- platform: gpio\n  pin:\n  number: GPIO13\n  inverted: true\n  id: button\n  name: ${friendly_name}_Button\n  on_press:\n  - switch.toggle: relay_template\n    internal: True\n\noutput:\n# Relay state led\n- platform: esp8266_pwm\n  id: state_led\n  pin:\n  number: GPIO2\n  inverted: true\n\nlight:\n# Relay state light\n- platform: monochromatic\n  output: state_led\n  id: led\n\nswitch:\n# Hardware Relay: Relay that triggers the output plug\n- platform: gpio\n  pin: GPIO15\n  id: relay\n\n- platform: template\n  name: ${friendly_name}_Relay\n  id: relay_template\n  lambda: |-\n  if (id(relay).state) {\n  return true;\n  } else {\n  return false;\n  }\n  turn_on_action:\n  - light.turn_on: led      # Turns on blue LED while relay on\n  - switch.turn_on: relay   # Turns relay on\n    turn_off_action:\n  - light.turn_off: led     # Turns off blue LED while relay off\n  - switch.turn_off: relay  # Turns relay off\n\n# ==============\n# !!! Notice !!!\n# ==============\n# To disable the status LED feature put # in front of the following 4 lines\n# If disabled, you wont get any error flashings on the LED from the plug.\nstatus_led:\npin:\nnumber: GPIO0                         # Default: RED GPIO0 / BLUE GPIO2\ninverted: true\n\n# Enable time component to reset energy at midnight\ntime:\n- platform: sntp                        # Uses NTP protocol for time information\n  id: my_time                           # Uses my local time from compiling\n\ntext_sensor:\n- platform: template\n  name: ${friendly_name}_Uptime         # Enable Uptime-Sensor in readable format    \n  id: uptime_readable\n  icon: mdi:clock-start\n- platform: version\n  name: ${friendly_name}_version        # Show module Version in structure\n- platform: wifi_info\n  ip_address:\n  name: ${friendly_name}_ip           # Show WIFI IP-address in structure\n  ssid:\n  name: ${friendly_name}_ssid         # Show WIFI SSID in structure\n  bssid:\n  name: ${friendly_name}_bssid        # Show WIFI BSSID in structure\n')])])])]),n._v(" "),t("h3",{attrs:{id:"sp112-bl0937"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sp112-bl0937"}},[n._v("#")]),n._v(" SP112 BL0937")]),n._v(" "),t("details",[t("summary",[n._v(" Vorlage anzeigen\n")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('####\n#\n# Configuration File for GOSUND SP112 / BLITZWOLF SHP5\n# - If you switch from Tasmota - check if you have BL0937 on GPIO5, then this config can be used.\n#\n# Notices:\n# ========\n# - There are different versions of SP112 / SHP5, they differ with other GPIO-Pinouts and other sensor platforms!\n# - You have to create a "SECRETS.YAML" first (!) and VALIDATE (!) this configuration before uploading to plug!!!\n#\n# Useful Links:\n# ========\n# Calibrate Power Source: https://frenck.dev/calibrating-an-esphome-flashed-power-plug/\n#\n# Builddate: 14.04.2021 by X-R4Y\n#\n####\n\nsubstitutions:\ndevice_id:      gosund_sp112  # Device-ID Unique (only lowercase!)\ndevice_name:    gosund_sp112  # Device-Type for Category (only lowercase!)\nfriendly_name:  gosund_sp112  # Device-Name for Channel (Lower-/Uppercase allowed)\n\nesphome:\nname: $device_name\nplatform: ESP8266\narduino_version: 2.5.1\nboard: esp01_1m\n\nwifi:\nssid:         !secret wifi_ssid\npassword:     !secret wifi_password\nfast_connect: on\n\n# Optional manual IP\n#  manual_ip:\n#    static_ip:  !secret ip_gosund_sp112_1\n#    gateway:    !secret ip_gateway\n#    subnet:     !secret ip_netmask\n#    dns1:       !secret ip_dns_1\ndomain:       !secret ip_domain\n\n# Enable fallback hotspot (captive portal) in case wifi connection fails\n#  ap:\n#    ssid: $device_name_Hotspot_Fallback\n#    password: "fallback"\n\n# Enable if you wish to have a minimalistic web-interface for your device\n#web_server:\n#  port: 80\n\napi:\npassword: !secret api_password\n\nota:\npassword: !secret ota_password\n\nlogger:           # Reduce log level as otherwise logs would be flooded with analog sensor readings\nlogs:\nsensor: ERROR # Options INFO / WARN / ERROR\nadc: ERROR    # Options INFO / WARN / ERROR\n\nsensor:\n- platform: adc\n  id: button_adc\n  pin: A0\n  update_interval: .1s\n- platform: hlw8012\n  sel_pin:\n  number: GPIO12\n  inverted: True\n  cf_pin: GPIO05\n  cf1_pin: GPIO04\n  current:\n  id: current\n  name: ${friendly_name}_Current\n  unit_of_measurement: A\n  accuracy_decimals: 3\n\n  voltage:\n  id: voltage\n  name: ${friendly_name}_Voltage\n  unit_of_measurement: V\n  accuracy_decimals: 1\n\n  power:\n  id: wattage\n  name: ${friendly_name}_Power\n  unit_of_measurement: W\n  accuracy_decimals: 2\n  filters:\n  - lambda: return (x / 2.2);\n\n- platform: total_daily_energy\n  power_id: wattage\n  name: ${friendly_name}_Daily_Energy\n  unit_of_measurement: kWh\n  filters:\n  # Multiplication factor from W to kW is 0.001\n  - multiply: 0.001\n\n- platform: wifi_signal\n  name: ${friendly_name}_WiFi_Information\n  update_interval: 60s\n\n- platform: uptime\n  id: uptime_sensor\n  name: ${friendly_name}_Uptime_Information\n  update_interval: 60s\n  on_raw_value:\n  then:\n  - text_sensor.template.publish:\n  id: uptime_readable\n  state: !lambda |-\n  int seconds = round(id(uptime_sensor).raw_state);\n  int days = seconds / (24 * 3600);\n  seconds = seconds % (24 * 3600);\n  int hours = seconds / 3600;\n  seconds = seconds % 3600;\n  int minutes = seconds /  60;\n  seconds = seconds % 60;\n  return (\n  (days ? String(days) + "d " : "") +\n  (hours ? String(hours) + "h " : "") +\n  (minutes ? String(minutes) + "m " : "") +\n  (String(seconds) + "s")\n  ).c_str();\n\nbinary_sensor:\n- platform: template\n  id: hardwarebutton\n  # read analog sensor and convert it\'s value to binary state\n  lambda: return (id(button_adc).state < .5);\n  on_click:\n  - min_length: 10ms        # short button press toggles mains (< 250ms)\n    max_length: 250ms\n    then:\n    - switch.toggle: switch_voltage\n  - min_length: 500ms       # long button press toggles USB (> 500ms up to 2 seconds)\n    max_length: 2000ms\n    then:\n    - switch.toggle: switch_usb\n\noutput:\n- platform: gpio\n  id: red_led_output            # Red LED\n  pin:\n  number: GPIO00\n  inverted: true\n\n- platform: gpio\n  id: blue_led_output           # Blue LED\n  pin:\n  number: GPIO02\n  inverted: true\n\nswitch:\n- platform: gpio\n  name: ${friendly_name}_Relay_Voltage\n  id: switch_voltage\n  pin: GPIO14\n  #inverted: true               # Some devices need this to be enabled\n  on_turn_on:\n  output.turn_on: red_led_output\n  on_turn_off:\n  output.turn_off: red_led_output\n\n- platform: gpio\n  name: ${friendly_name}_Relay_USB\n  id: switch_usb\n  pin: GPIO13\n  inverted:  true\n  on_turn_on:\n  output.turn_on: blue_led_output\n  on_turn_off:\n  output.turn_off: blue_led_output\n\n# ==============\n# !!! Notice !!!\n# ==============\n# Enabled: the Red LED will not light up while relay is in off-state!\n# Disabled: you wont get any error flashings on the LED from the plug.\n# To disable the status LED feature put # in front of the following 4 lines\nstatus_led:\npin:\nnumber: GPIO2                         # Default: RED GPIO0 / BLUE GPIO2\ninverted: true\n\n# Enable time component to reset energy at midnight\ntime:\n- platform: sntp                        # Uses NTP protocol for time information\n  id: my_time                           # Uses my local time from compiling\n\ntext_sensor:\n- platform: template\n  name: ${friendly_name}_Uptime         # Enable Uptime-Sensor in readable format    \n  id: uptime_readable\n  icon: mdi:clock-start\n- platform: version\n  name: ${friendly_name}_version        # Show module Version in structure\n- platform: wifi_info\n  ip_address:\n  name: ${friendly_name}_ip           # Show WIFI IP-address in structure\n  ssid:\n  name: ${friendly_name}_ssid         # Show WIFI SSID in structure\n  bssid:\n  name: ${friendly_name}_bssid        # Show WIFI BSSID in structure\n')])])])]),n._v(" "),t("h3",{attrs:{id:"sp112-cse7766"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sp112-cse7766"}},[n._v("#")]),n._v(" SP112 CSE7766")]),n._v(" "),t("details",[t("summary",[n._v(" Vorlage anzeigen\n")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('####\n#\n# Configuration File for GOSUND SP112 / BLITZWOLF SHP5\n# - If you switch from Tasmota - check if you have CSE7766 in your template then this config can be used.\n#\n# Notices:\n# ========\n# - There are different versions of SP112 / SHP5, they differ with other GPIO-Pinouts and other sensor platforms!\n# - You have to create a "SECRETS.YAML" first (!) and VALIDATE (!) this configuration before uploading to plug!!!\n#\n# Useful Links:\n# ========\n# Calibrate Power Source: https://frenck.dev/calibrating-an-esphome-flashed-power-plug/\n#\n# Builddate: 14.04.2021 by X-R4Y\n#\n####\n\nsubstitutions:\ndevice_id:      gosund_sp112    # Device-ID Unique (only lowercase)\ndevice_name:    gosund_sp112    # Device-Type for Category (only lowercase!)\nfriendly_name:  gosund_sp112    # Device-Name for Channel (Lower-/Uppercase allowed)\n\nesphome:\nname: $device_name\nplatform: ESP8266\nboard: esp8285\n\nwifi:\nssid:         !secret wifi_ssid\npassword:     !secret wifi_password\nfast_connect: on\n\n# Optional manual IP\n#  manual_ip:\n#    static_ip:  !secret ip_gosund_sp112_1\n#    gateway:    !secret ip_gateway\n#    subnet:     !secret ip_netmask\n#    dns1:       !secret ip_dns_1\ndomain:       !secret ip_domain\n\n# Enable fallback hotspot (captive portal) in case wifi connection fails\n#  ap:\n#    ssid: $device_name_Hotspot_Fallback\n#    password: "fallback"\n\n# Enable if you wish to have a minimalistic web-interface for your device\n#web_server:\n#  port: 80\n\napi:\npassword: !secret api_password\n\nota:\npassword: !secret ota_password\n\nlogger:           # Reduce log level as otherwise logs would be flooded with analog sensor readings\nlogs:\nsensor: ERROR # Options INFO / WARN / ERROR\nadc: ERROR    # Options INFO / WARN / ERROR\n\nuart:\nrx_pin: RX\nbaud_rate: 4800\n\nsensor:\n- platform: cse7766\n  current:\n  id: current\n  name: ${friendly_name}_Current\n  unit_of_measurement: A\n  accuracy_decimals: 3\n\n  voltage:\n  id: voltage\n  name: ${friendly_name}_Voltage\n  unit_of_measurement: V\n  accuracy_decimals: 1\n\n  power:\n  id: wattage\n  name: ${friendly_name}_Power\n  unit_of_measurement: W\n  accuracy_decimals: 2\n  filters:\n  - lambda: return (x / 2.2);\n\n- platform: total_daily_energy\n  power_id: wattage\n  name: ${friendly_name}_Daily_Energy\n  unit_of_measurement: kWh\n  filters:\n  # Multiplication factor from W to kW is 0.001\n  - multiply: 0.001\n\n- platform: wifi_signal\n  name: ${friendly_name}_WiFi_Information\n  update_interval: 60s\n\n- platform: uptime\n  id: uptime_sensor\n  name: ${friendly_name}_Uptime_Information\n  update_interval: 60s\n  on_raw_value:\n  then:\n  - text_sensor.template.publish:\n  id: uptime_readable\n  state: !lambda |-\n  int seconds = round(id(uptime_sensor).raw_state);\n  int days = seconds / (24 * 3600);\n  seconds = seconds % (24 * 3600);\n  int hours = seconds / 3600;\n  seconds = seconds % 3600;\n  int minutes = seconds /  60;\n  seconds = seconds % 60;\n  return (\n  (days ? String(days) + "d " : "") +\n  (hours ? String(hours) + "h " : "") +\n  (minutes ? String(minutes) + "m " : "") +\n  (String(seconds) + "s")\n  ).c_str();\n\nbinary_sensor:\n# Binary sensor for the hardware button press\n- platform: gpio\n  name: ${friendly_name}_button\n  id: relay\n  pin:\n  number: GPIO16\n  inverted: true\n  internal: True\n  on_press:\n  - switch.toggle: switch_usb\n  - switch.toggle: switch_voltage\n\noutput:\n- platform: gpio\n  id: red_led_output            # Red LED\n  pin:\n  number: GPIO00\n  inverted: true\n\n- platform: gpio\n  id: blue_led_output           # Blue LED\n  pin:\n  number: GPIO02\n  inverted: true\n\nswitch:\n- platform: gpio\n  name: ${friendly_name}_Relay_Voltage\n  id: switch_voltage\n  pin:\n  number: GPIO14\n#    inverted: true\non_turn_on:\noutput.turn_on: red_led_output\non_turn_off:\noutput.turn_off: red_led_output\n\n- platform: gpio\n  name: ${friendly_name}_Relay_USB\n  id: switch_usb\n  pin: GPIO5\n  #inverted:  true\n  on_turn_on:\n  output.turn_on: blue_led_output\n  on_turn_off:\n  output.turn_off: blue_led_output\n\n# ==============\n# !!! Notice !!!\n# ==============\n# Enabled: the Red LED will not light up while relay is in off-state!\n# Disabled: you wont get any error flashings on the LED from the plug.\n# To disable the status LED feature put # in front of the following 4 lines\nstatus_led:\npin:\nnumber: GPIO2                         # Default: RED GPIO0 / BLUE GPIO2\ninverted: true\n\n# Enable time component to reset energy at midnight\ntime:\n- platform: sntp                        # Uses NTP protocol for time information\n  id: my_time                           # Uses my local time from compiling\n\ntext_sensor:\n- platform: template\n  name: ${friendly_name}_Uptime         # Enable Uptime-Sensor in readable format    \n  id: uptime_readable\n  icon: mdi:clock-start\n- platform: version\n  name: ${friendly_name}_version        # Show module Version in structure\n- platform: wifi_info\n  ip_address:\n  name: ${friendly_name}_ip           # Show WIFI IP-address in structure\n  ssid:\n  name: ${friendly_name}_ssid         # Show WIFI SSID in structure\n  bssid:\n  name: ${friendly_name}_bssid        # Show WIFI BSSID in structure\n')])])])]),n._v(" "),t("h2",{attrs:{id:"teckin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#teckin"}},[n._v("#")]),n._v(" Teckin")]),n._v(" "),t("h3",{attrs:{id:"sp10"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sp10"}},[n._v("#")]),n._v(" SP10")]),n._v(" "),t("details",[t("summary",[n._v(" Vorlage anzeigen\n")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('####\n#\n# Configuration File for TECKIN-SP10\n#\n# Notices:\n# ========\n# - You have to create a "SECRETS.YAML" first (!) and VALIDATE (!) this configuration before uploading to plug!!!\n#\n# Builddate: 14.04.2021 by X-R4Y\n#\n####\nsubstitutions:\ndevice_id:      teckin_sp10   # Device-ID Unique\ndevice_name:    teckin_sp10   # Device-Type for Category\nfriendly_name:  teckin_sp10   # Device-Name for Channel\n\nesphome:\nname: $device_name\nplatform: ESP8266\nboard: esp01_1m\nesp8266_restore_from_flash: true\n\nwifi:\nssid:         !secret wifi_ssid\npassword:     !secret wifi_password\nfast_connect: on\n\n# Optional manual IP\n#  manual_ip:\n#    static_ip:  !secret ip_gosund_sp1\n#    gateway:    !secret ip_gateway\n#    subnet:     !secret ip_netmask\n#    dns1:       !secret ip_dns_1\ndomain:       !secret ip_domain\n\n# Enable fallback hotspot (captive portal) in case wifi connection fails\n#  ap:\n#    ssid: $device_name_Hotspot_Fallback\n#    password: "fallback"\n\n# Enable if you wish to have a minimalistic web-interface for your device\n#web_server:\n#  port: 80\n\nlogger:\n# https://esphome.io/components/logger\n\napi:\npassword: !secret api_password\n\nota:\npassword: !secret ota_password\n\nsensor:\n- platform: wifi_signal\n  name: ${friendly_name}_WiFi_Information\n  update_interval: 60s\n\n- platform: uptime\n  name: ${friendly_name}_Uptime_Information\n  id: uptime_sensor\n  update_interval: 60s\n  on_raw_value:\n  then:\n  - text_sensor.template.publish:\n  id: uptime_readable\n  state: !lambda |-\n  int seconds = round(id(uptime_sensor).raw_state);\n  int days = seconds / (24 * 3600);\n  seconds = seconds % (24 * 3600);\n  int hours = seconds / 3600;\n  seconds = seconds % 3600;\n  int minutes = seconds /  60;\n  seconds = seconds % 60;\n  return (\n  (days ? String(days) + "d " : "") +\n  (hours ? String(hours) + "h " : "") +\n  (minutes ? String(minutes) + "m " : "") +\n  (String(seconds) + "s")\n  ).c_str();\n\nbinary_sensor:\n# Hardware Button at plug to turn on/off relay manually\n- platform: gpio\n  pin:\n  number: GPIO13\n  id: button\n  name: ${friendly_name}_Button\n  on_press:\n  - switch.toggle: relay_template\n    internal: True\n\noutput:\n# https://esphome.io/components/output/esp8266_pwm.html\n- platform: esp8266_pwm\n  id: blue_led_output\n  pin:\n  number: GPIO2\n  inverted: True\n\nlight:\n# https://esphome.io/components/light/monochromatic.html\n- platform: monochromatic\n  name: blue_led\n  output: blue_led_output\n  id: blue_led\n  default_transition_length: 1ms # default 1s\n  internal: True\n\nswitch:\n# Hardware Relay: Relay that triggers the output plug\n- platform: gpio\n  pin: GPIO15\n  id: relay\n\n- platform: template\n  name: ${friendly_name}_Relay\n  id: relay_template\n  lambda: |-\n  if (id(relay).state) {\n  return true;\n  } else {\n  return false;\n  }\n  turn_on_action:\n  - light.turn_on: blue_led   # Turns on blue LED while relay on\n  - switch.turn_on: relay     # Turns relay on\n    turn_off_action:\n  - light.turn_off: blue_led  # Turns off blue LED while relay off\n  - switch.turn_off: relay    # Turns relay off\n\n# ==============\n# !!! Notice !!!\n# ==============\n# If enabled, the Red LED will not light up while relay is in off-state!\n# To disable the status LED feature put # in front of the following 4 lines\n# If disabled, you wont get any error flashings on the LED from the plug.\nstatus_led:\npin:\nnumber: GPIO0                         # Default: RED GPIO0 / BLUE GPIO2\ninverted: true\n\ntext_sensor:\n- platform: template\n  name: ${friendly_name}_Uptime         # Enable Uptime-Sensor in readable format    \n  id: uptime_readable\n  icon: mdi:clock-start\n- platform: version\n  name: ${friendly_name}_version        # Show module Version in structure\n- platform: wifi_info\n  ip_address:\n  name: ${friendly_name}_ip           # Show WIFI IP-address in structure\n  ssid:\n  name: ${friendly_name}_ssid         # Show WIFI SSID in structure\n  bssid:\n  name: ${friendly_name}_bssid        # Show WIFI BSSID in structure\n')])])])]),n._v(" "),t("h3",{attrs:{id:"sp20"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sp20"}},[n._v("#")]),n._v(" SP20")]),n._v(" "),t("details",[t("summary",[n._v(" Vorlage anzeigen\n")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('####\n#\n# Configuration File for TECKIN-SP20\n# - If you switch from Tasmota - check if you have HLW8012 in your template then this config can be used.\n#\n# Notices:\n# ========\n# - You have to create a "SECRETS.YAML" first (!) and VALIDATE (!) this configuration before uploading to plug!!!\n#\n# Useful Links:\n# ========\n# Calibrate Power Source: https://frenck.dev/calibrating-an-esphome-flashed-power-plug/\n# To finetune your wattage/voltage measurement, check the substitutions "current_res / voltage_div"\n#\n# Builddate: 14.04.2021 by X-R4Y\n#\n####\nsubstitutions:\ndevice_id:      teckin_sp20       # Device-ID Unique\ndevice_name:    teckin_sp20       # Device-Type for Category\nfriendly_name:  Teckin_SP20       # Device-Name for Channel\ncurrent_res:    \'0.001906\'        # Higher value gives lower watt readout (Default 0.001906)\nvoltage_div:    \'950\'             # Lower value gives lower voltage readout\n\nesphome:\nname: $device_name\nplatform: ESP8266\nboard: esp01_1m\nesp8266_restore_from_flash: true\n\nwifi:\nssid:         !secret wifi_ssid\npassword:     !secret wifi_password\nfast_connect: on\n\n# Optional manual IP\n#  manual_ip:\n#    static_ip:  !secret ip_gosund_sp1_1\n#    gateway:    !secret ip_gateway\n#    subnet:     !secret ip_netmask\n#    dns1:       !secret ip_dns_1\ndomain:       !secret ip_domain\n\n# Enable fallback hotspot (captive portal) in case wifi connection fails\n#  ap:\n#    ssid: $device_name_Hotspot_Fallback\n#    password: "fallback"\n\n# Enable if you wish to have a minimalistic web-interface for your device\n#web_server:\n#  port: 80\n\nlogger:\n# https://esphome.io/components/logger\n\napi:\npassword: !secret api_password\n\nota:\npassword: !secret ota_password\n\nsensor:\n- platform: hlw8012\n  # https://esphome.io/components/sensor/hlw8012.html\n  # current, power, voltage can all use sensor options https://esphome.io/components/sensor/#config-sensor\n  sel_pin:\n  number: GPIO12\n  inverted: True\n  cf_pin: GPIO5\n  cf1_pin: GPIO14\n\n  current:\n  name: ${friendly_name}_Current\n  unit_of_measurement: A\n  accuracy_decimals: 3\n\n  power:\n  name: ${friendly_name}_Power\n  id: power_monitor_value\n  unit_of_measurement: W\n  accuracy_decimals: 2\n  filters:\n  - lambda: return (x / 2.2);\n\n  voltage:\n  name: ${friendly_name}_Voltage\n  unit_of_measurement: V\n  accuracy_decimals: 2\n  current_resistor: $current_res\n  voltage_divider: $voltage_div\n  change_mode_every: 5            # default 8\n  update_interval: 15s            # default 60s\n\n  energy:\n  name: ${friendly_name}_Energy\n  unit_of_measurement: "Wh"\n\n- platform: total_daily_energy\n  name: ${friendly_name}_Total_Daily_Energy\n  power_id: power_monitor_value\n  filters:\n  - multiply: 0.001         # convert Wh to kWh\n    unit_of_measurement: kWh\n\n- platform: wifi_signal\n  name: ${friendly_name}_WiFi_Information\n  update_interval: 60s\n\n- platform: uptime\n  name: ${friendly_name}_Uptime_Information\n  id: uptime_sensor\n  update_interval: 60s\n  on_raw_value:\n  then:\n  - text_sensor.template.publish:\n  id: uptime_readable\n  state: !lambda |-\n  int seconds = round(id(uptime_sensor).raw_state);\n  int days = seconds / (24 * 3600);\n  seconds = seconds % (24 * 3600);\n  int hours = seconds / 3600;\n  seconds = seconds % 3600;\n  int minutes = seconds /  60;\n  seconds = seconds % 60;\n  return (\n  (days ? String(days) + "d " : "") +\n  (hours ? String(hours) + "h " : "") +\n  (minutes ? String(minutes) + "m " : "") +\n  (String(seconds) + "s")\n  ).c_str();\n\nbinary_sensor:\n# Hardware Button at plug to turn on/off relay manually\n- platform: gpio\n  pin:\n  number: GPIO13\n  id: button\n  name: ${friendly_name}_Button\n  on_press:\n  - switch.toggle: relay_template\n    internal: True\n\noutput:\n# Hardware LEDs: Blue and Red, triggering on different states\n- platform: gpio\n  id: red_led_output    # Status LED RED\n  pin:\n  number: GPIO0\n  inverted: True\n\n- platform: gpio\n  id: blue_led_output   # Status LED BLUE\n  pin:\n  number: GPIO2\n  inverted: True\n\nswitch:\n# Hardware Relay: Relay that triggers the output plug\n- platform: gpio\n  pin: GPIO4\n  id: relay\n\n- platform: template\n  name: ${friendly_name}_Relay\n  id: relay_template\n  lambda: |-\n  if (id(relay).state) {\n  return true;\n  } else {\n  return false;\n  }\n  turn_on_action:\n  - output.turn_on: blue_led_output   # Turns on blue LED while relay on\n  - output.turn_off: red_led_output   # Turns off red LED while relay on\n  - switch.turn_on: relay             # Turns relay on\n    turn_off_action:\n  - output.turn_off: blue_led_output  # Turns off blue LED while relay off\n  - output.turn_on: red_led_output    # Turns on red LED while relay off\n  - switch.turn_off: relay            # Turns relay off\n\n# ==============\n# !!! Notice !!!\n# ==============\n# If enabled, the Red LED will not light up while relay is in off-state!\n# To disable the status LED feature put # in front of the following 4 lines\n# If disabled, you wont get any error flashings on the LED from the plug.\n#status_led:\n#  pin:\n#    number: GPIO0                         # Default: RED GPIO0 / BLUE GPIO2\n#    inverted: true\n\n# Enable time component to reset energy at midnight\ntime:\n- platform: sntp                        # Uses NTP protocol for time information\n  id: my_time                           # Uses my local time from compiling\n\ntext_sensor:\n- platform: template\n  name: ${friendly_name}_Uptime         # Enable Uptime-Sensor in readable format    \n  id: uptime_readable\n  icon: mdi:clock-start\n- platform: version\n  name: ${friendly_name}_version        # Show module Version in structure\n- platform: wifi_info\n  ip_address:\n  name: ${friendly_name}_ip           # Show WIFI IP-address in structure\n  ssid:\n  name: ${friendly_name}_ssid         # Show WIFI SSID in structure\n  bssid:\n  name: ${friendly_name}_bssid        # Show WIFI BSSID in structure\n')])])])]),n._v(" "),t("h2",{attrs:{id:"sonoff"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sonoff"}},[n._v("#")]),n._v(" Sonoff")]),n._v(" "),t("blockquote",[t("p",[n._v("ToDo<")])]),n._v(" "),t("h2",{attrs:{id:"shelly"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shelly"}},[n._v("#")]),n._v(" Shelly")]),n._v(" "),t("blockquote",[t("p",[n._v("ToDo<")])]),n._v(" "),t("h2",{attrs:{id:"vansware"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vansware"}},[n._v("#")]),n._v(" Vansware")]),n._v(" "),t("h3",{attrs:{id:"vansware-plug-with-led-ring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vansware-plug-with-led-ring"}},[n._v("#")]),n._v(" VANSWARE Plug (with LED Ring)")]),n._v(" "),t("details",[t("summary",[n._v(" Vorlage anzeigen\n")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('####\n#\n# Configuration File for VANSWARE Plug (with LED Ring)\n# - If you switch from Tasmota - check if you have BL0937 on GPIO5, then this config can be used.\n#\n# Notices:\n# ========\n# - You have to create a "SECRETS.YAML" first (!) and VALIDATE (!) this configuration before uploading to plug!!!\n#\n# Useful Links:\n# ========\n# Calibrate Power Source: https://frenck.dev/calibrating-an-esphome-flashed-power-plug/\n#\n# Builddate: 15.04.2021 by X-R4Y (alias V!P3R_76 @ Discord)\n#\n####\n\nsubstitutions:\ndevice_id:      vansware    # Device-ID Unique (only lowercase!)\ndevice_name:    vansware    # Device-Type for Category (only lowercase!)\nfriendly_name:  vansware    # Device-Name for Channel (Lower-/Uppercase allowed)\ncurrent_res:    \'0.001906\'  # Higher value gives lower watt readout (Default 0.001906)\nvoltage_div:    \'912\'       # Lower value gives lower voltage readout (Default 912 ~ 226V)\n\nesphome:\nname: $device_name\nplatform: ESP8266\narduino_version: 2.5.1\nboard: esp8285\n\nwifi:\nssid:         !secret wifi_ssid\npassword:     !secret wifi_password\nfast_connect: on\n\n# Optional manual IP\n#  manual_ip:\n#    static_ip:  !secret ip_vansware\n#    gateway:    !secret ip_gateway\n#    subnet:     !secret ip_netmask\n#    dns1:       !secret ip_dns_1\ndomain:       !secret ip_domain\n\n# Enable fallback hotspot (captive portal) in case wifi connection fails\n#  ap:\n#    ssid: $device_name_Hotspot_Fallback\n#    password: "fallback"\n\n# Enable if you wish to have a minimalistic web-interface for your device\nweb_server:\nport: 80\n\napi:\npassword: !secret api_password\n\nota:\npassword: !secret ota_password\n\nlogger:           # Reduce log level as otherwise logs would be flooded with analog sensor readings\nlogs:\nsensor: ERROR # Options INFO / WARN / ERROR\nadc: ERROR    # Options INFO / WARN / ERROR\n\nsensor:\n- platform: hlw8012\n  # https://esphome.io/components/sensor/hlw8012.html\n  # current, power, voltage can all use sensor options https://esphome.io/components/sensor/#config-sensor\n  sel_pin:\n  number: GPIO12\n  inverted: True\n  cf_pin: GPIO5\n  cf1_pin: GPIO14\n\n  current:\n  name: ${friendly_name}_Current\n  unit_of_measurement: A\n  accuracy_decimals: 3\n\n  power:\n  name: ${friendly_name}_Power\n  id: power_monitor_value\n  unit_of_measurement: W\n  accuracy_decimals: 2\n  filters:\n  - lambda: return (x / 2.2);\n\n  voltage:\n  name: ${friendly_name}_Voltage\n  unit_of_measurement: V\n  accuracy_decimals: 2\n  current_resistor: $current_res  # default 0.001\n  voltage_divider: $voltage_div   # default 2351\n  change_mode_every: 3            # default 8\n  update_interval: 10s            # default 60s\n\n  energy:\n  name: ${friendly_name}_Energy\n  unit_of_measurement: "Wh"\n\n- platform: total_daily_energy\n  name: ${friendly_name}_Total_Daily_Energy\n  power_id: power_monitor_value\n  filters:\n  - multiply: 0.001         # convert Wh to kWh\n    unit_of_measurement: kWh\n\n- platform: wifi_signal\n  name: ${friendly_name}_WiFi_Information\n  update_interval: 60s\n\n- platform: uptime\n  name: ${friendly_name}_Uptime_Information\n  id: uptime_sensor\n  update_interval: 60s\n  on_raw_value:\n  then:\n  - text_sensor.template.publish:\n  id: uptime_readable\n  state: !lambda |-\n  int seconds = round(id(uptime_sensor).raw_state);\n  int days = seconds / (24 * 3600);\n  seconds = seconds % (24 * 3600);\n  int hours = seconds / 3600;\n  seconds = seconds % 3600;\n  int minutes = seconds /  60;\n  seconds = seconds % 60;\n  return (\n  (days ? String(days) + "d " : "") +\n  (hours ? String(hours) + "h " : "") +\n  (minutes ? String(minutes) + "m " : "") +\n  (String(seconds) + "s")\n  ).c_str();\n\nbinary_sensor:\n# Hardware Button at plug to turn on/off relay manually\n- platform: gpio\n  pin:\n  number: GPIO13\n  id: button\n  name: ${friendly_name}_Button\n  on_press:\n  - switch.toggle: relay_template\n    internal: True\n\noutput:\n# Hardware LEDs: Blue and Red, triggering on different states\n- platform: esp8266_pwm\n  id: red_led\n  pin:\n  number: GPIO0\n  inverted: true\n- platform: esp8266_pwm\n  id: green_led\n  pin:\n  number: GPIO4\n  inverted: true\n- platform: esp8266_pwm\n  id: blue_led\n  pin:\n  number: GPIO2\n  inverted: true\n\nlight:\n- platform: monochromatic\n  id: light1\n  output: red_led\n  name: ${friendly_name}_LED1_Red\n- platform: monochromatic\n  id: light2\n  output: green_led\n  name: ${friendly_name}_LED2_Green\n- platform: monochromatic\n  id: light3\n  output: blue_led\n  name: ${friendly_name}_LED3_Blue\n\nswitch:\n# Hardware Relay: Relay that triggers the output plug\n- platform: gpio\n  pin: GPIO15\n  id: relay\n\n- platform: template\n  name: ${friendly_name}_Relay\n  id: relay_template\n  lambda: |-\n  if (id(relay).state) {\n  return true;\n  } else {\n  return false;\n  }\n  turn_on_action:\n  - output.turn_on: red_led           # Turns on blue LED while relay on\n  - output.turn_off: green_led        # Turns off red LED while relay on\n  - switch.turn_on: relay             # Turns relay on\n    turn_off_action:\n  - output.turn_off: red_led          # Turns off blue LED while relay off\n  - output.turn_on: green_led         # Turns on red LED while relay off\n  - switch.turn_off: relay            # Turns relay off\n\n# ==============\n# !!! Notice !!!\n# ==============\n# To disable the status LED feature put # in front of the following 4 lines\n# If disabled, you wont get any error flashings on the LED from the plug.\nstatus_led:\npin:\nnumber: GPIO2                         # Default: RED GPIO0 / GREEN GPIO4 / BLUE GPIO2\ninverted: true\n\n# Enable time component to reset energy at midnight\ntime:\n- platform: sntp                        # Uses NTP protocol for time information\n  id: my_time                           # Uses my local time from compiling\n\ntext_sensor:\n- platform: template\n  name: ${friendly_name}_Uptime         # Enable Uptime-Sensor in readable format    \n  id: uptime_readable\n  icon: mdi:clock-start\n- platform: version\n  name: ${friendly_name}_version        # Show module Version in structure\n- platform: wifi_info\n  ip_address:\n  name: ${friendly_name}_ip           # Show WIFI IP-address in structure\n  ssid:\n  name: ${friendly_name}_ssid         # Show WIFI SSID in structure\n  bssid:\n  name: ${friendly_name}_bssid        # Show WIFI BSSID in structure\n')])])])]),n._v(" "),t("blockquote",[t("p",[n._v("ToDo<")])])])}),[],!1,null,null,null);e.default=r.exports}}]);